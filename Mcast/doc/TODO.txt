Questions a millorar en protocol multicast
----------------------------------------------

S'ha de canviar el subsistema de comunicació entre el kernel i l'aplicació. Actualment s'utilitza el /proc per a obtenir tota la informació de routing i la configuració de les interfícies ethernet. Aixó tindria sentit només en aplicacions sense privilegis de superusuari, peró no és el cas i llavors s'han d'aprofitar altres alternatives millors. La forma més óptima és la comunicació aplicació - kernel mitjançant netlink, i programant sobre la API rtnetlink que dóna el kernel per comunicar-se amb el sistema de enrutat IP. El problema està en la mala documentació i en el suport incomplet del protocol IPv6, a més de la dificultat que implica treballar amb crides al kernel. També hi han altres opcions, del tot incompletes, com ioctl() o sysctl(), que només serveixen per consultar coses molt específiques i no podem obtenir tota la taula de routing. També es podria estudiar treballar contra la API del dimoni de routing ZEBRA, peró ja vam tenir molts problemes treballant normalment amb les últimes versions d'aquest dimoni i no vam voler arriscar-nos amb la API. A més a més, si en lloc de Linux d'hagés treballat amb *BSD, es podria haver aprofitat els routing sockets que proporcionen una manera còmode de modificar i obtenir la taula de routing. A més, es un sistema que s'utilitza desde fa molts anys i està ben documentat.

Un altre problema és la mala implementació dels últims RFC sobre IPv6 al kernel de linux. Actualment el grup de treball USAGI està millorant aixó, però encara falta feina per fer. La migració a la implementació dual-stack IPv4 i IPv6 és complexa i funcions o crides al kernel que han de suportar ambdós protocols no funcionen (p.ex. la funció if_nameindex() no funciona tal i com diu l'API);

Aquest problema va provocar que es pogués utilitzar la API normal i corrent (basada en BSD) per a fer sockets RAW, i és que la implementació no permet utilitzar els raw sockets IPv6 tal i com anaven en IPv4 ja que no hi han tantes opcions disponibles. A més a més les extension headers són complicades d'utilitzar i es troba a faltar una API més senzilla que la definida als RFC de IPv6 (3493 i 3542).

Actualment s'utilitzen llibreries d'alt nivell com libpcap per la lectura de paquets i libnet per l'injecció a la xarxa. Aquestes llibreries no són eficients i carregen molt la CPU, i aixó es milloraria moltíssim si utilitzessim la API del kernel. També carrega molt la CPU el fet de llegir fitxers del /proc continuament, i tenir que processar-los cada cop que arriba un paquet. Aixó també es milloraria si utilitzéssim netlink. 

Finalment, cal fer una neteja de codi i utilitzar llistes enllaçades amb memòria dinàmica, i no llistes estàtiques inicialitzades a un tamany gran de memória. També es podría millorar els prototips de les funcions i mirar d' utilitzar funcions on totes les crides siguin per referència (més óptim) i cap sigui per valor, malgrat que la majoria ja són així.

Com a conclusió podríem dir que el projecte es podria millorar treballant en una plataforma que suporti millor IPv6, com és FreeBSD ja que el seu projecte KAME per a IPv6 porta molts anys. Així utilitzaríem només crides a sistema (routing sockets) i APIs estándar (definides als rfc de IPv6), obtenint així un codi totalment "estandar" i molt optimitzat.
